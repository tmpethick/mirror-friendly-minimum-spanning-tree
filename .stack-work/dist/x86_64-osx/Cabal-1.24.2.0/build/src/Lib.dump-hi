
==================== FINAL INTERFACE ====================
2017-11-04 17:57:18.345281 UTC

interface hard-project-0.1.0.0-JiLdRhV0AFMB55kjwkqqqB:Lib 8002
  interface hash: 21880ea94a7a79ec434cd3e294e64a65
  ABI hash: c0c0ea6914b1c449a52a783cd0a45823
  export-list hash: bb6fe39597539203172f27c5470baa9a
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 0eabcb25c680af911322a3bdf6f8c707
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lib.delPrimaryPartition
  Lib.edges'
  Lib.g
  Lib.getPartition
  Lib.getPendant
  Lib.getSecondaryPartitions
  Lib.hasOneEdge
  Lib.n
  Lib.neighborCombinations
  Lib.nodes'
  Lib.pairNeighbors
  Lib.powerset
  Lib.powersetWithoutEmptySet
  Lib.primaryPartitions
  Lib.removePartition
  Lib.removePendant
  Lib.root
  Lib.toNodes
  Lib.Partition{Lib.EdgePart Lib.NodePart}
module dependencies:
package dependencies: OneTuple-0.2.1@OneTuple-0.2.1-7xFCZYYP3bD3K0JO3QlNLg
                      array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0
                      fgl-5.6.0.0@fgl-5.6.0.0-7hDKrnuXAeL5gWTTppBflt ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
                      tuple-0.3.0.2@tuple-0.3.0.2-fw19c2mVE4S4kTOAA0LW
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         fgl-5.6.0.0@fgl-5.6.0.0-7hDKrnuXAeL5gWTTppBflt:Data.Graph.Inductive.PatriciaTree
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.Functor 5ab1dc703df5b482e77efb697833ca3c
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  fgl-5.6.0.0@fgl-5.6.0.0-7hDKrnuXAeL5gWTTppBflt:Data.Graph.Inductive.Basic 250830a8372b7f1b518a73cf4bfec6a4
import  -/  fgl-5.6.0.0@fgl-5.6.0.0-7hDKrnuXAeL5gWTTppBflt:Data.Graph.Inductive.Graph e955cb47bdc9d4d6eea65af47837ed8e
import  -/  fgl-5.6.0.0@fgl-5.6.0.0-7hDKrnuXAeL5gWTTppBflt:Data.Graph.Inductive.PatriciaTree 4a9b47808f26099226146e2570939ef7
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  tuple-0.3.0.2@tuple-0.3.0.2-fw19c2mVE4S4kTOAA0LW:Data.Tuple.Select 405e4c165e81b4fa47e7a29436c65100
9d6c89070f2453eeb53d2c4336d33925
  $tc'EdgePart :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   223796576977675720##
                   4326863725922868143##
                   Lib.$trModule
                   Lib.$tc'EdgePart1) -}
0d8eabca840d92c41bcf53eccf71e925
  $tc'EdgePart1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'EdgePart"#) -}
d98e157a174f7d26229987c3348791ce
  $tc'NodePart :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15776212702434053676##
                   16295895955314900543##
                   Lib.$trModule
                   Lib.$tc'NodePart1) -}
56fdf3c509d53b324bbc72967ee3e5f6
  $tc'NodePart1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NodePart"#) -}
44e5fb9ea22486a4bf726941c702dd55
  $tcPartition :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13858529344304076160##
                   16340546641556961289##
                   Lib.$trModule
                   Lib.$tcPartition1) -}
65aad8bd6c48ef024dba588e9e528058
  $tcPartition1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Partition"#) -}
ead99ffae2962561846346032abde3d4
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Lib.$trModule2 Lib.$trModule1) -}
51be8d9a6cab926db7b036b5f4d95701
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Lib"#) -}
31bb2be1ea75a2836ceec4b607e8f37a
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "hard-project-0.1.0.0-JiLdRhV0AFMB55kjwkqqqB"#) -}
4ff16b2c533fa84786c0dde6036a01fa
  $wneighborCombinations ::
    Lib.Partition t1
    -> Lib.Partition t
    -> [(Data.Graph.Inductive.Graph.Node,
         Data.Graph.Inductive.Graph.Node)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ @ t
                   @ t1
                   (ww :: Lib.Partition t1)
                   (ww1 :: Lib.Partition t) ->
                 let {
                   xs :: [Data.Graph.Inductive.Graph.Node]
                   = case ww1 of wild {
                       Lib.EdgePart ds
                       -> case ds of wild1 { (,,) n1 n2 ds1 ->
                          GHC.Types.:
                            @ Data.Graph.Inductive.Graph.Node
                            n1
                            (GHC.Types.:
                               @ Data.Graph.Inductive.Graph.Node
                               n2
                               (GHC.Types.[] @ Data.Graph.Inductive.Graph.Node)) }
                       Lib.NodePart n1
                       -> GHC.Types.:
                            @ Data.Graph.Inductive.Graph.Node
                            n1
                            (GHC.Types.[] @ Data.Graph.Inductive.Graph.Node) }
                 } in
                 case ww of wild {
                   Lib.EdgePart ds
                   -> case ds of wild1 { (,,) n1 n2 ds1 ->
                      letrec {
                        go :: [GHC.Types.Int]
                              -> [(Data.Graph.Inductive.Graph.Node,
                                   Data.Graph.Inductive.Graph.Node)]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds2 :: [GHC.Types.Int]) ->
                          case ds2 of wild2 {
                            []
                            -> GHC.Types.[]
                                 @ (Data.Graph.Inductive.Graph.Node,
                                    Data.Graph.Inductive.Graph.Node)
                            : y ys
                            -> let {
                                 ys1 :: [(Data.Graph.Inductive.Graph.Node,
                                          Data.Graph.Inductive.Graph.Node)]
                                 = go ys
                               } in
                               letrec {
                                 go1 :: [Data.Graph.Inductive.Graph.Node]
                                        -> [(Data.Graph.Inductive.Graph.Node,
                                             Data.Graph.Inductive.Graph.Node)]
                                   {- Arity: 1, Strictness: <S,1*U> -}
                                 = \ (ds3 :: [Data.Graph.Inductive.Graph.Node]) ->
                                   case ds3 of wild3 {
                                     [] -> ys1
                                     : y1 ys2
                                     -> GHC.Types.:
                                          @ (Data.Graph.Inductive.Graph.Node,
                                             Data.Graph.Inductive.Graph.Node)
                                          (y, y1)
                                          (go1 ys2) }
                               } in
                               go1 xs }
                      } in
                      go
                        (GHC.Types.:
                           @ Data.Graph.Inductive.Graph.Node
                           n1
                           (GHC.Types.:
                              @ Data.Graph.Inductive.Graph.Node
                              n2
                              (GHC.Types.[] @ Data.Graph.Inductive.Graph.Node))) }
                   Lib.NodePart n1
                   -> letrec {
                        go :: [Data.Graph.Inductive.Graph.Node]
                              -> [(Data.Graph.Inductive.Graph.Node,
                                   Data.Graph.Inductive.Graph.Node)]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds :: [Data.Graph.Inductive.Graph.Node]) ->
                          case ds of wild1 {
                            []
                            -> GHC.Types.[]
                                 @ (Data.Graph.Inductive.Graph.Node,
                                    Data.Graph.Inductive.Graph.Node)
                            : y ys
                            -> GHC.Types.:
                                 @ (Data.Graph.Inductive.Graph.Node,
                                    Data.Graph.Inductive.Graph.Node)
                                 (n1, y)
                                 (go ys) }
                      } in
                      go xs }) -}
e736490c341ace45beef01595318e379
  data Partition a
    = EdgePart (Data.Graph.Inductive.Graph.LEdge a)
    | NodePart Data.Graph.Inductive.Graph.Node
a6d5bbbfd8f484e1a02c07c8beaf4aed
  delPrimaryPartition ::
    (Data.Tuple.Select.Sel2 a Data.Graph.Inductive.Graph.Node,
     Data.Tuple.Select.Sel1 a Data.Graph.Inductive.Graph.Node,
     Data.Graph.Inductive.Graph.Graph gr) =>
    gr a1 b -> [a] -> gr a1 b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,C(U)><L,C(U)><L,1*U(A,A,1*U,A,A,A,A,A,A)><S,1*U><S,U>,
     Unfolding: (\ @ a
                   @ (gr :: * -> * -> *)
                   @ a1
                   @ b
                   ($dSel2 :: Data.Tuple.Select.Sel2
                                a Data.Graph.Inductive.Graph.Node)
                   ($dSel1 :: Data.Tuple.Select.Sel1
                                a Data.Graph.Inductive.Graph.Node)
                   ($dGraph :: Data.Graph.Inductive.Graph.Graph gr)
                   (g4 :: gr a1 b)
                   (pp :: [a]) ->
                 let {
                   z :: [GHC.Types.Int]
                   = GHC.Base.map
                       @ a
                       @ GHC.Types.Int
                       $dSel2
                         `cast`
                       (Data.Tuple.Select.N:Sel2[0] <a>_N <Data.Graph.Inductive.Graph.Node>_N)
                       pp
                 } in
                 letrec {
                   go :: [a] -> [GHC.Types.Int] {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [a]) ->
                     case ds of wild {
                       [] -> z
                       : y ys
                       -> GHC.Types.:
                            @ GHC.Types.Int
                            ($dSel1
                               `cast`
                             (Data.Tuple.Select.N:Sel1[0] <a>_N <Data.Graph.Inductive.Graph.Node>_N)
                               y)
                            (go ys) }
                 } in
                 Data.Graph.Inductive.Graph.delNodes
                   @ gr
                   @ a1
                   @ b
                   $dGraph
                   (go pp)
                   g4) -}
9cf1a071b5fe4c7e63a6d9b214111013
  edges' :: [Data.Graph.Inductive.Graph.LEdge GHC.Types.Int]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Data.Graph.Inductive.Graph.LEdge GHC.Types.Int)
                   Lib.edges'23
                   Lib.edges'1) -}
d16a4e71a1788256aa88b6a141d7397c
  edges'1 :: [Data.Graph.Inductive.Graph.LEdge GHC.Types.Int]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Data.Graph.Inductive.Graph.LEdge GHC.Types.Int)
                   Lib.edges'22
                   Lib.edges'2) -}
69f97d4867e9c2973f7ef5ba9f9029aa
  edges'10 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 5#) -}
8bc2dd833e9711c3cf1448636dccebd3
  edges'11 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 4#) -}
b31e32c027a8c0dcf06f2b6e81db1df3
  edges'12 :: (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Lib.edges'14, Lib.edges'11, Lib.edges'13)) -}
89b01a0c7d315af2e263040e7a3758f5
  edges'13 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 7#) -}
a78e70afac440bc28284f611af82a32d
  edges'14 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 3#) -}
4c6c4a99a143c86a124a477f9c0b991e
  edges'15 :: (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Lib.edges'17, Lib.edges'10, Lib.edges'16)) -}
d1f42569f19a1f0144643c9e6b25b23e
  edges'16 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 6#) -}
d49cc5f654ae2f5040bbfbf6bfa87c79
  edges'17 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 2#) -}
68ac1ec238b55b3184c24d031cfed81a
  edges'18 :: (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Lib.edges'17, Lib.edges'14, Lib.edges'10)) -}
d67ce5b453447edbf24bfc73b3c7f662
  edges'19 :: (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Lib.edges'20, Lib.edges'16, Lib.edges'11)) -}
c2acabf1dfeffaaa6a77357b76eda416
  edges'2 :: [Data.Graph.Inductive.Graph.LEdge GHC.Types.Int]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Data.Graph.Inductive.Graph.LEdge GHC.Types.Int)
                   Lib.edges'21
                   Lib.edges'3) -}
7e3f505604520408b499d952f2db4150
  edges'20 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
7b0f4e8b49a254a70823ad0b53fc2f23
  edges'21 :: (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Lib.edges'20, Lib.edges'11, Lib.edges'14)) -}
3c7d8d26a96850cfbfac174fd0572083
  edges'22 :: (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Lib.edges'20, Lib.edges'14, Lib.edges'17)) -}
01d2784f239b4b9c2614eb7d0ae31c82
  edges'23 :: (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Lib.edges'20, Lib.edges'17, Lib.edges'20)) -}
3aa3f83372d192bbc202fab55329c925
  edges'3 :: [Data.Graph.Inductive.Graph.LEdge GHC.Types.Int]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Data.Graph.Inductive.Graph.LEdge GHC.Types.Int)
                   Lib.edges'19
                   Lib.edges'4) -}
de7b65f8b4d0f11c8b05980395a00611
  edges'4 :: [Data.Graph.Inductive.Graph.LEdge GHC.Types.Int]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Data.Graph.Inductive.Graph.LEdge GHC.Types.Int)
                   Lib.edges'18
                   Lib.edges'5) -}
671f93d54d19aca29f398562f2489da8
  edges'5 :: [Data.Graph.Inductive.Graph.LEdge GHC.Types.Int]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Data.Graph.Inductive.Graph.LEdge GHC.Types.Int)
                   Lib.edges'15
                   Lib.edges'6) -}
82b680a5d4c734711af4720b17e9aad1
  edges'6 :: [Data.Graph.Inductive.Graph.LEdge GHC.Types.Int]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Data.Graph.Inductive.Graph.LEdge GHC.Types.Int)
                   Lib.edges'12
                   Lib.edges'7) -}
ed9df5a9ad62241878127f0be894d3fb
  edges'7 :: [Data.Graph.Inductive.Graph.LEdge GHC.Types.Int]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Data.Graph.Inductive.Graph.LEdge GHC.Types.Int)
                   Lib.edges'8
                   (GHC.Types.[]
                      @ (Data.Graph.Inductive.Graph.LEdge GHC.Types.Int))) -}
adde14af46ed506a891c1a1514703962
  edges'8 :: (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Lib.edges'11, Lib.edges'10, Lib.edges'9)) -}
f541946e6e1481fedf464c0ba08ee1fc
  edges'9 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 8#) -}
94b38a669b1f394064e76c3d8132c565
  g ::
    Data.Graph.Inductive.PatriciaTree.Gr GHC.Types.Int GHC.Types.Int
  {- Unfolding: (Data.Graph.Inductive.Basic.undir
                   @ GHC.Types.Int
                   @ Data.Graph.Inductive.PatriciaTree.Gr
                   @ GHC.Types.Int
                   GHC.Classes.$fEqInt
                   Data.Graph.Inductive.PatriciaTree.$fDynGraphGr
                   Lib.g1) -}
ff6a74c4c09dd9c7bd5afc9ec1817a4c
  g1 ::
    Data.Graph.Inductive.PatriciaTree.Gr GHC.Types.Int GHC.Types.Int
  {- Unfolding: (Data.Graph.Inductive.PatriciaTree.$fGraphGr9
                   @ GHC.Types.Int
                   @ GHC.Types.Int
                   Lib.edges'
                   Lib.g2
                     `cast`
                   (Sym (Data.Graph.Inductive.PatriciaTree.N:Gr[0]
                             <GHC.Types.Int>_R <GHC.Types.Int>_R))) -}
9b48740e8c296f06ec292db79ef31d10
  g2 ::
    Data.IntMap.Base.IntMap
      (Data.IntMap.Base.IntMap [GHC.Types.Int], GHC.Types.Int,
       Data.IntMap.Base.IntMap [GHC.Types.Int])
  {- Unfolding: (Data.IntMap.Base.fromList1
                   @ (Data.IntMap.Base.IntMap [GHC.Types.Int], GHC.Types.Int,
                      Data.IntMap.Base.IntMap [GHC.Types.Int])
                   (Data.IntMap.Base.Nil
                      @ (Data.IntMap.Base.IntMap [GHC.Types.Int], GHC.Types.Int,
                         Data.IntMap.Base.IntMap [GHC.Types.Int]))
                   Lib.g3) -}
79bd4fcc74da8437a9e737bcfc956f4d
  g3 ::
    [(Data.IntSet.Base.Key,
      (Data.IntMap.Base.IntMap [GHC.Types.Int], GHC.Types.Int,
       Data.IntMap.Base.IntMap [GHC.Types.Int]))]
  {- Unfolding: (GHC.Base.map
                   @ (Data.IntSet.Base.Key, GHC.Types.Int)
                   @ (Data.IntSet.Base.Key,
                      (Data.IntMap.Base.IntMap [GHC.Types.Int], GHC.Types.Int,
                       Data.IntMap.Base.IntMap [GHC.Types.Int]))
                   (Data.Graph.Inductive.PatriciaTree.$fGraphGr8
                      @ GHC.Types.Int
                      @ GHC.Types.Int)
                   Lib.nodes') -}
1216a57db7b6acc46b29810c1e5c3a30
  getPartition ::
    Data.Graph.Inductive.PatriciaTree.Gr a a1 -> Lib.Partition a1
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ @ a
                   @ a1
                   (pg :: Data.Graph.Inductive.PatriciaTree.Gr a a1) ->
                 let {
                   n1 :: Data.Graph.Inductive.Graph.Node
                   = case Data.Graph.Inductive.PatriciaTree.$fGraphGr_$clabNodes
                            @ a
                            @ a1
                            pg of wild {
                       [] -> GHC.List.badHead @ GHC.Types.Int
                       : y ys -> case y of wild1 { (,) x ds1 -> x } }
                 } in
                 case Data.Graph.Inductive.Graph.out
                        @ Data.Graph.Inductive.PatriciaTree.Gr
                        @ a
                        @ a1
                        Data.Graph.Inductive.PatriciaTree.$fGraphGr
                        pg
                        n1 of wild {
                   [] -> Lib.NodePart @ a1 n1 : h t -> Lib.EdgePart @ a1 h }) -}
f86fe67bf4da27ca7196e8837b28f735
  getPendant ::
    Data.Graph.Inductive.Graph.DynGraph gr =>
    gr a b
    -> Data.Graph.Inductive.Graph.Node
    -> [Data.Graph.Inductive.Graph.Node]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(LLC(C(S(SL)))LLLLLL)L),U(U(A,A,C(C1(U(1*U,A))),A,A,A,A,A,A),A)><L,U><L,U>,
     Unfolding: (\ @ (gr :: * -> * -> *)
                   @ a
                   @ b
                   ($dDynGraph :: Data.Graph.Inductive.Graph.DynGraph gr)
                   (eta :: gr a b)
                   (eta1 :: Data.Graph.Inductive.Graph.Node) ->
                 let {
                   lvl1 :: Data.Graph.Inductive.Graph.Graph gr
                   = Data.Graph.Inductive.Graph.$p1DynGraph @ gr $dDynGraph
                 } in
                 letrec {
                   go :: [(Data.Graph.Inductive.Graph.Node,
                           Data.Graph.Inductive.Graph.Node, b)]
                         -> [GHC.Types.Int]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [(Data.Graph.Inductive.Graph.Node,
                                Data.Graph.Inductive.Graph.Node, b)]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ GHC.Types.Int
                       : y ys
                       -> let {
                            x :: GHC.Types.Int = case y of wild1 { (,,) ds1 x1 ds2 -> x1 }
                          } in
                          case GHC.List.$wlenAcc
                                 @ (Data.Graph.Inductive.Graph.Node,
                                    Data.Graph.Inductive.Graph.Node, b)
                                 (Data.Graph.Inductive.Graph.out @ gr @ a @ b lvl1 eta x)
                                 0# of ww2 {
                            DEFAULT -> go ys 1# -> GHC.Types.: @ GHC.Types.Int x (go ys) } }
                 } in
                 go (Data.Graph.Inductive.Graph.out @ gr @ a @ b lvl1 eta eta1)) -}
fef7c43d13569322052e72c196030c80
  getSecondaryPartitions ::
    Data.Graph.Inductive.PatriciaTree.Gr a t -> [Lib.Partition t]
  {- Arity: 1, Strictness: <S,1*U> -}
84220a22280cfc6de548c646ba15aaf9
  hasOneEdge ::
    Data.Graph.Inductive.Graph.DynGraph gr =>
    gr a b -> Data.Graph.Inductive.Graph.Node -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(LLC(C(S(SL)))LLLLLL)L),1*U(1*U(A,A,1*C1(C1(U(1*U,A))),A,A,A,A,A,A),A)><L,U><L,U>,
     Unfolding: (\ @ (gr :: * -> * -> *)
                   @ a
                   @ b
                   ($dDynGraph :: Data.Graph.Inductive.Graph.DynGraph gr)
                   (eta :: gr a b)
                   (eta1 :: Data.Graph.Inductive.Graph.Node) ->
                 case GHC.List.$wlenAcc
                        @ (Data.Graph.Inductive.Graph.Node,
                           Data.Graph.Inductive.Graph.Node, b)
                        (Data.Graph.Inductive.Graph.out
                           @ gr
                           @ a
                           @ b
                           (Data.Graph.Inductive.Graph.$p1DynGraph @ gr $dDynGraph)
                           eta
                           eta1)
                        0# of ww2 {
                   DEFAULT -> GHC.Types.False 1# -> GHC.Types.True }) -}
c21f95c140a1db28da604aa179129b64
  n :: Data.Graph.Inductive.Graph.Node
  {- Unfolding: (case Data.Graph.Inductive.PatriciaTree.$fGraphGr_$clabNodes
                        @ GHC.Types.Int
                        @ GHC.Types.Int
                        Lib.g of wild {
                   [] -> GHC.List.badHead @ GHC.Types.Int
                   : y ys -> case y of wild1 { (,) x ds1 -> x } }) -}
c907b1c99983e6d1cfebd5d38dad7b4b
  neighborCombinations ::
    (Lib.Partition t1, Lib.Partition t)
    -> [(Data.Graph.Inductive.Graph.Node,
         Data.Graph.Inductive.Graph.Node)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ t @ t1 (w :: (Lib.Partition t1, Lib.Partition t)) ->
                 case w of ww { (,) ww1 ww2 ->
                 Lib.$wneighborCombinations @ t @ t1 ww1 ww2 }) -}
0a4da659d9216788b598898435bfcef4
  nodes' :: [Data.Graph.Inductive.Graph.LNode GHC.Types.Int]
  {- Unfolding: (Lib.nodes'_go 1# Lib.nodes'1) -}
b81002aca3bde9ca18dfb393edf5e725
  nodes'1 :: [GHC.Types.Int]
  {- Unfolding: (GHC.Enum.eftInt 1# 6#) -}
ecfc4dd678b203efbd26ed9df4e02411
  nodes'_go ::
    GHC.Prim.Int#
    -> [GHC.Types.Int] -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
e13ae5b6d5d613e8887f8e8968f1d9b0
  pairNeighbors :: [b] -> [(b, b)]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ b (l :: [b]) ->
                 GHC.Base.build
                   @ (b, b)
                   (\ @ b1 (c :: (b, b) -> b1 -> b1)[OneShot] (n1 :: b1)[OneShot] ->
                    GHC.List.foldr2
                      @ b
                      @ b
                      @ b1
                      (GHC.List.zipFB @ b @ b @ b1 @ b1 c)
                      n1
                      l
                      (case l of wild { [] -> GHC.List.scanl2 @ b : ds1 xs -> xs }))) -}
f5a5e40e80525f194f075681659bd80c
  powerset :: [a] -> [[a]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
56f6068052fbeb5361123f936302630c
  powersetWithoutEmptySet :: [a] -> [[a]]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: [a]) ->
                 case Lib.powerset @ a x of wild {
                   [] -> GHC.List.init2 @ [a]
                   : x1 xs -> GHC.List.init1 @ [a] x1 xs }) -}
7055a76b90093ed2ed08d42d8d06c2d3
  primaryPartitions ::
    Data.Graph.Inductive.Graph.Graph gr =>
    gr a b
    -> Data.Graph.Inductive.Graph.Node
    -> [[Data.Graph.Inductive.Graph.LEdge b]]
  {- Arity: 3,
     Strictness: <S(LLC(C(S(SL)))LLLLLL),1*U(A,A,1*C1(C1(U(1*U,A))),A,A,A,A,A,A)><L,U><L,U>,
     Unfolding: (\ @ a
                   @ (gr :: * -> * -> *)
                   @ b
                   ($dGraph :: Data.Graph.Inductive.Graph.Graph gr)
                   (g4 :: gr a b)
                   (n1 :: Data.Graph.Inductive.Graph.Node) ->
                 case Lib.powerset
                        @ (Data.Graph.Inductive.Graph.LEdge b)
                        (Data.Graph.Inductive.Graph.out
                           @ gr
                           @ a
                           @ b
                           $dGraph
                           g4
                           n1) of wild {
                   [] -> GHC.List.init2 @ [Data.Graph.Inductive.Graph.LEdge b]
                   : x xs
                   -> GHC.List.init1 @ [Data.Graph.Inductive.Graph.LEdge b] x xs }) -}
ce778b6f80e6b2316ff9d4fedb451bc9
  removePartition ::
    Data.Graph.Inductive.Graph.Graph gr =>
    Lib.Partition t -> gr a b -> gr a b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,A,1*U,A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: (\ @ (gr :: * -> * -> *)
                   @ t
                   @ a
                   @ b
                   ($dGraph :: Data.Graph.Inductive.Graph.Graph gr)
                   (ds :: Lib.Partition t)
                   (g4 :: gr a b) ->
                 case ds of wild {
                   Lib.EdgePart e
                   -> let {
                        pp :: [Data.Graph.Inductive.Graph.LEdge t]
                        = GHC.Types.:
                            @ (Data.Graph.Inductive.Graph.LEdge t)
                            e
                            (GHC.Types.[] @ (Data.Graph.Inductive.Graph.LEdge t))
                      } in
                      let {
                        z :: [GHC.Types.Int]
                        = GHC.Base.map
                            @ (Data.Graph.Inductive.Graph.LEdge t)
                            @ GHC.Types.Int
                            (Data.Tuple.Select.$fSel2(,,)a2_$csel2
                               @ GHC.Types.Int
                               @ GHC.Types.Int
                               @ t)
                            pp
                      } in
                      letrec {
                        go :: [Data.Graph.Inductive.Graph.LEdge t] -> [GHC.Types.Int]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds1 :: [Data.Graph.Inductive.Graph.LEdge t]) ->
                          case ds1 of wild1 {
                            [] -> z
                            : y ys
                            -> GHC.Types.:
                                 @ GHC.Types.Int
                                 (Data.Tuple.Select.$fSel1(,,)a1_$csel1
                                    @ GHC.Types.Int
                                    @ GHC.Types.Int
                                    @ t
                                    y)
                                 (go ys) }
                      } in
                      Data.Graph.Inductive.Graph.delNodes @ gr @ a @ b $dGraph (go pp) g4
                   Lib.NodePart n1
                   -> Data.Graph.Inductive.Graph.delNode
                        @ gr
                        @ a
                        @ b
                        $dGraph
                        n1
                        g4 }) -}
85d551ef52ce79ab47b2b7c3fcbf6192
  removePartition_$sremovePartition ::
    Lib.Partition t
    -> Data.Graph.Inductive.PatriciaTree.Gr a b
    -> Data.Graph.Inductive.PatriciaTree.Gr a b
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ @ t
                   @ a
                   @ b
                   (ds :: Lib.Partition t)
                   (g4 :: Data.Graph.Inductive.PatriciaTree.Gr a b) ->
                 case ds of wild {
                   Lib.EdgePart e
                   -> let {
                        pp :: [Data.Graph.Inductive.Graph.LEdge t]
                        = GHC.Types.:
                            @ (Data.Graph.Inductive.Graph.LEdge t)
                            e
                            (GHC.Types.[] @ (Data.Graph.Inductive.Graph.LEdge t))
                      } in
                      let {
                        z :: [GHC.Types.Int]
                        = GHC.Base.map
                            @ (Data.Graph.Inductive.Graph.LEdge t)
                            @ GHC.Types.Int
                            (Data.Tuple.Select.$fSel2(,,)a2_$csel2
                               @ GHC.Types.Int
                               @ GHC.Types.Int
                               @ t)
                            pp
                      } in
                      letrec {
                        go :: [Data.Graph.Inductive.Graph.LEdge t] -> [GHC.Types.Int]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds1 :: [Data.Graph.Inductive.Graph.LEdge t]) ->
                          case ds1 of wild1 {
                            [] -> z
                            : y ys
                            -> GHC.Types.:
                                 @ GHC.Types.Int
                                 (Data.Tuple.Select.$fSel1(,,)a1_$csel1
                                    @ GHC.Types.Int
                                    @ GHC.Types.Int
                                    @ t
                                    y)
                                 (go ys) }
                      } in
                      Data.Graph.Inductive.Graph.delNodes
                        @ Data.Graph.Inductive.PatriciaTree.Gr
                        @ a
                        @ b
                        Data.Graph.Inductive.PatriciaTree.$fGraphGr
                        (go pp)
                        g4
                   Lib.NodePart n1
                   -> Data.Graph.Inductive.Graph.delNodes
                        @ Data.Graph.Inductive.PatriciaTree.Gr
                        @ a
                        @ b
                        Data.Graph.Inductive.PatriciaTree.$fGraphGr
                        (GHC.Types.:
                           @ Data.Graph.Inductive.Graph.Node
                           n1
                           (GHC.Types.[] @ Data.Graph.Inductive.Graph.Node))
                        g4 }) -}
6ffd5e46e96b75bb9bdb1eac036009ca
  removePendant ::
    (Data.Graph.Inductive.Graph.DynGraph gr, GHC.Classes.Eq b) =>
    gr a b -> [Data.Graph.Inductive.Graph.Node] -> gr a b
  {- Arity: 4,
     Strictness: <L,U(U(U,U,U,U,U,U,U,U,U),C(C1(U)))><L,U(C(C1(U)),A)><L,U><S,U>,
     Unfolding: (\ @ (gr :: * -> * -> *)
                   @ b
                   @ a
                   ($dDynGraph :: Data.Graph.Inductive.Graph.DynGraph gr)
                   ($dEq :: GHC.Classes.Eq b)
                   (eta :: gr a b)
                   (eta1 :: [Data.Graph.Inductive.Graph.Node]) ->
                 let {
                   $dGraph :: Data.Graph.Inductive.Graph.Graph gr
                   = Data.Graph.Inductive.Graph.$p1DynGraph @ gr $dDynGraph
                 } in
                 let {
                   z :: gr a b
                   = letrec {
                       go :: [GHC.Types.Int] -> gr a b {- Arity: 1, Strictness: <S,1*U> -}
                       = \ (ds :: [GHC.Types.Int]) ->
                         case ds of wild {
                           [] -> eta
                           : y ys
                           -> case Data.Graph.Inductive.Graph.inn
                                     @ gr
                                     @ a
                                     @ b
                                     $dGraph
                                     eta
                                     y of wild1 {
                                [] -> case GHC.List.badHead ret_ty (gr a b) of {}
                                : x ds1
                                -> case x of ww { (,,) ww1 ww2 ww3 ->
                                   Data.Graph.Inductive.Graph.$wdelAllLEdge
                                     @ gr
                                     @ b
                                     @ a
                                     $dDynGraph
                                     $dEq
                                     ww1
                                     ww2
                                     ww3
                                     (go ys) } } }
                     } in
                     go eta1
                 } in
                 letrec {
                   go :: [GHC.Types.Int] -> gr a b {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Types.Int]) ->
                     case ds of wild {
                       [] -> z
                       : y ys
                       -> case Data.Graph.Inductive.Graph.out
                                 @ gr
                                 @ a
                                 @ b
                                 $dGraph
                                 eta
                                 y of wild1 {
                            [] -> case GHC.List.badHead ret_ty (gr a b) of {}
                            : x ds1
                            -> case x of ww { (,,) ww1 ww2 ww3 ->
                               Data.Graph.Inductive.Graph.$wdelAllLEdge
                                 @ gr
                                 @ b
                                 @ a
                                 $dDynGraph
                                 $dEq
                                 ww1
                                 ww2
                                 ww3
                                 (go ys) } } }
                 } in
                 go eta1) -}
16ea4254d32c172d48b90e9720dd4146
  root ::
    Data.Graph.Inductive.PatriciaTree.Gr a b
    -> Data.Graph.Inductive.Graph.Node
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b (x :: Data.Graph.Inductive.PatriciaTree.Gr a b) ->
                 case Data.Graph.Inductive.PatriciaTree.$fGraphGr_$clabNodes
                        @ a
                        @ b
                        x of wild {
                   [] -> GHC.List.badHead @ GHC.Types.Int
                   : y ys
                   -> Data.Tuple.fst @ Data.Graph.Inductive.Graph.Node @ a y }) -}
d4edd3a3da4f4f9c824a112bd176803b
  toNodes :: Lib.Partition t -> [Data.Graph.Inductive.Graph.Node]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ @ t (ds :: Lib.Partition t) ->
                 case ds of wild {
                   Lib.EdgePart ds1
                   -> case ds1 of wild1 { (,,) n1 n2 ds2 ->
                      GHC.Types.:
                        @ Data.Graph.Inductive.Graph.Node
                        n1
                        (GHC.Types.:
                           @ Data.Graph.Inductive.Graph.Node
                           n2
                           (GHC.Types.[] @ Data.Graph.Inductive.Graph.Node)) }
                   Lib.NodePart n1
                   -> GHC.Types.:
                        @ Data.Graph.Inductive.Graph.Node
                        n1
                        (GHC.Types.[] @ Data.Graph.Inductive.Graph.Node) }) -}
"SPEC removePartition @ Gr _ _ _" [ALWAYS] forall @ t
                                                  @ a
                                                  @ b
                                                  ($dGraph :: Data.Graph.Inductive.Graph.Graph
                                                                Data.Graph.Inductive.PatriciaTree.Gr)
  Lib.removePartition @ Data.Graph.Inductive.PatriciaTree.Gr
                      @ t
                      @ a
                      @ b
                      $dGraph
  = Lib.removePartition_$sremovePartition @ t @ a @ b
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

